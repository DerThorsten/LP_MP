#ifndef LP_MP_COSEGMENTATION_HXX
#define LP_MP_COSEGMENTATION_HXX

#include "cosegmentation_bins.h"
#include "problem_decomposition.hxx"

#include "factors_messages.hxx"
#include "LP_MP.h"
#include "factors/multiplex_factor.hxx"
#include "factors/simplex_factor_simd.hxx"
#include "const_array_types.h"
#include "messages/multiplex_marg_message.hxx"
#include "messages/equality_message.hxx"
#include "marginal_summation_message.hxx"
#include "problem_construction_helper.hxx"

#include "message_replicator.hxx"
#include "message_replicator_factor.hxx"

#include "assignment_problem_construction.hxx"

#include <iostream>
#include <fstream>
#include <string>
#include <tuple>
#include <exception>
#include <algorithm>
#include <memory>

namespace LP_MP {

// similar to quadratic assignment problem, except that we use modified Potts factors and no other quadratic potentials
// many functions are duplicates from graph_matching
// do zrobienia: implement cosegmentation with bins

// file format:
// first entries: assignment problem:
// problem 0
// a l r cost -> assignment from left node number l to right node number r with specified cost
//
// then: MRF-problem
// problem 1
// potts 2 i1 i2 cost
// potts factor with 2 labels between node i1 and i2
// question: Make 1 problem for left and right image separately?
//
// joining MRF and Assignment problem:
// problem 2
// {l|r}+no i
// {left|right} variable no and mrf variable i.

class Cosegmentation {
public:
   Cosegmentation() : lp_(nullptr), assignmentProblem_() {}
   ~Cosegmentation() { delete lp_; }
   
   Cosegmentation& SetNumberLeftNodes(const INDEX nodeNumber) { assignmentProblem_.SetNumberLeftNodes(nodeNumber); return *this; }
   Cosegmentation& SetNumberRightNodes(const INDEX nodeNumber) { assignmentProblem_.SetNumberRightNodes(nodeNumber); return *this;}
   Cosegmentation& AddAssignmentCost(const INDEX leftNode, const INDEX rightNode, const REAL cost) { assignmentProblem_.AddAssignmentCost(leftNode, rightNode, cost); return *this;}
   Cosegmentation& AddLeftPottsTerm(const INDEX leftNode1, const INDEX leftNode2, const REAL cost);
   Cosegmentation& AddRightPottsTerm(const INDEX rightNode1, const INDEX rightNode2, const REAL cost);
   Cosegmentation& Solve(const INDEX nIter);
   std::vector<int> GetLeftSegmentation();
   std::vector<int> GetRightSegmentation();
   REAL dualBound() {return lp_->LowerBound();};
   REAL evalLeft(const std::vector<int>& seg);
   REAL evalRight(const std::vector<int>& seg);
   REAL evalAssignment(const std::vector<int>& assignment);
   REAL primalBound() { return 0.0; };

private:
   //specification for underlying factor/message-network
   // do zrobienia: hardcode 2 labels for more efficient message passing
   typedef UnaryLoop UnaryLoopType;
   typedef PairwiseLoop<0> LeftLoopType;
   typedef PairwiseLoop<1> RightLoopType;

   typedef MultiplexMargMessage<UnaryLoopType,LeftLoopType,true,false> LeftMargMessage;
   typedef MultiplexMargMessage<UnaryLoopType,RightLoopType,true,false> RightMargMessage;

   struct FMC; // forward declaration

   // factors
   typedef MultiplexFactor<std::vector<REAL>, const_ones_array, const_one> Simplex;
   typedef FactorContainer<Simplex, ExplicitRepamStorage, FMC, 0 > UnaryFactor; // 2 entries: foreground, background. do zrobienia: specialize factor
   typedef FactorContainer<Simplex, ExplicitRepamStorage, FMC, 1 > PairwiseFactor; // 4 entries for pairwise potential. do zrobienia: specialize factor
   typedef FactorContainer<Simplex, ExplicitRepamStorage, FMC, 2 > AssignmentFactor; // for each pixel: number of possible assignments

   // messages
   typedef MessageContainer<EqualityMessage, FixedMessageStorage<1>, FMC, 0 > AssignmentConstraintMessage;
   typedef MessageContainer<LeftMargMessage, MessageStorageSIMD, FMC, 1 > UnaryPairwiseMessageLeft; // unary has left_dim entries
   typedef MessageContainer<RightMargMessage, MessageStorageSIMD, FMC, 2 > UnaryPairwiseMessageRight; // unary has right_dim entries
   typedef MessageContainer<MarginalSummationMessage, FixedMessageStorage<2>, FMC, 3> MarginalSummationMessageContainer; // for bin size 1

   struct FMC {
      using factor_list = meta::list< UnaryFactor, PairwiseFactor, AssignmentFactor>;
      using msg_list = meta::list< 
                                   meta::list< AssignmentConstraintMessage, meta::size_t<2>, meta::size_t<2>, std::vector<AssignmentConstraintMessage*>, std::vector<AssignmentConstraintMessage*> >,
                                   meta::list< UnaryPairwiseMessageLeft,  meta::size_t<0>, meta::size_t<1>, std::vector<UnaryPairwiseMessageLeft*>, FixedSizeContainer<UnaryPairwiseMessageLeft*,1> >,
                                   meta::list< UnaryPairwiseMessageRight, meta::size_t<0>, meta::size_t<1>, std::vector<UnaryPairwiseMessageRight*>, FixedSizeContainer<UnaryPairwiseMessageRight*,1> >,
                                   meta::list< MarginalSummationMessageContainer, meta::size_t<0>, meta::size_t<2>, FixedSizeContainer<MarginalSummationMessageContainer*,1>, FixedSizeContainer<MarginalSummationMessageContainer*,1> >
                                      >;
   };


   //Cosegmentation& SetNumberNodes(const INDEX nodeNumber, std::vector<std::vector<INDEX> >& graph);
   // construct the MRF-graph with pairwise interactions without the assignment
   void ConstructGraph(
         const std::map<std::pair<INDEX,INDEX>, REAL>& PottsCost,
         std::vector<UnaryFactor*>& unaryFactor, 
         std::vector<PairwiseFactor*>& pairwiseFactor);
   /*
   void ConstructAssignmentFactors(
         const std::vector<std::vector<REAL> >& cost,
         std::vector<AssignmentFactor*>& assignmentFactor);
         */
   void ConstructSummationConstraints(
         const std::vector<UnaryFactor*>& unaryFactor,
         const std::vector<AssignmentFactor*>& assignmentFactor);
   /*
   void ConstructAssignmentConstraints(
         const std::vector<std::vector<INDEX> >& graph1,
         const std::vector<AssignmentFactor*>& assignmentFactor1,
         const std::vector<std::vector<INDEX> >& graph2,
         const std::vector<AssignmentFactor*>& assignmentFactor2);
         */

   REAL eval(
         const std::vector<int>& assignment,
         const std::vector<std::vector<INDEX> >& graph, 
      const std::vector<std::vector<REAL> >& unaryCost,
      const std::map<std::pair<INDEX,INDEX>, REAL>& pottsCost);

   LP* lp_;
   // data structures for the underlying assignment problem
   // {left|right}-graph specify possible assignments from the left and right image. 
   // in unaryCost{Left_|Right_} there is one more entry than in {left|right}graph_, which is the cost for non-assignment

   std::vector<UnaryFactor*> leftUnaryFactor_;
   std::vector<UnaryFactor*> rightUnaryFactor_;

   std::vector<PairwiseFactor*> leftPairwiseFactor_;
   std::vector<PairwiseFactor*> rightPairwiseFactor_;

   AssignmentProblemConstructor<FMC, 2, 0 > assignmentProblem_;

   //std::vector<std::vector<INDEX> > leftGraph_, rightGraph_;

   //std::vector<AssignmentFactor*> leftAssignmentFactor_;
   //std::vector<AssignmentFactor*> rightAssignmentFactor_;

   //std::vector<std::vector<REAL> > unaryCostLeft_;
   //std::vector<std::vector<REAL> > unaryCostRight_;

   std::map<std::pair<INDEX,INDEX>, REAL> leftPottsCost_;
   std::map<std::pair<INDEX,INDEX>, REAL> rightPottsCost_;
};

} // end namespace LP_MP

#endif // LP_MP_COSEGMENTATION_HXX
